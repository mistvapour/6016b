#!/usr/bin/env python3
"""
MQTT PDFÂ§ÑÁêÜÊµÅÊ∞¥Á∫øÊºîÁ§∫
ÂàõÂª∫Ê®°ÊãüÊï∞ÊçÆÂ±ïÁ§∫ÂÆåÊï¥ÊµÅÁ®ã
"""
import json
import yaml
from pathlib import Path
from datetime import datetime

def create_mock_sim():
    """ÂàõÂª∫Ê®°ÊãüÁöÑMQTT SIMÊï∞ÊçÆ"""
    return {
        "standard": "OASIS MQTT",
        "edition": "5.0",
        "transport_unit": "byte",
        "enums": [
            {
                "key": "mqtt_qos",
                "items": [
                    {"code": "0", "label": "At most once", "description": "Fire and forget"},
                    {"code": "1", "label": "At least once", "description": "Acknowledged delivery"},
                    {"code": "2", "label": "Exactly once", "description": "Assured delivery"}
                ]
            },
            {
                "key": "mqtt_packet_type",
                "items": [
                    {"code": "1", "label": "CONNECT", "description": "Client request to connect to Server"},
                    {"code": "2", "label": "CONNACK", "description": "Connect acknowledgment"},
                    {"code": "3", "label": "PUBLISH", "description": "Publish message"},
                    {"code": "8", "label": "SUBSCRIBE", "description": "Client subscribe request"}
                ]
            }
        ],
        "spec_messages": [
            {
                "label": "CONNECT",
                "title": "Connect Packet", 
                "transport_unit": "byte",
                "segments": [
                    {
                        "type": "Fixed Header",
                        "seg_idx": 0,
                        "fields": [
                            {
                                "name": "Packet Type",
                                "length": 1,
                                "offset": 0,
                                "offset_unit": "byte",
                                "encoding": "UINT",
                                "description": "MQTT Control Packet Type"
                            },
                            {
                                "name": "Remaining Length",
                                "length": None,
                                "offset": 1,
                                "offset_unit": "byte", 
                                "encoding": "VBI",
                                "description": "Variable Byte Integer"
                            }
                        ]
                    },
                    {
                        "type": "Variable Header",
                        "seg_idx": 1,
                        "fields": [
                            {
                                "name": "Protocol Name",
                                "length": None,
                                "offset": None,
                                "offset_unit": "byte",
                                "encoding": "UTF8",
                                "description": "UTF-8 Encoded Protocol Name"
                            },
                            {
                                "name": "Protocol Version",
                                "length": 1,
                                "offset": None,
                                "offset_unit": "byte",
                                "encoding": "UINT",
                                "description": "Protocol Version Number"
                            },
                            {
                                "name": "Connect Flags", 
                                "length": 1,
                                "offset": None,
                                "offset_unit": "byte",
                                "encoding": "UINT",
                                "description": "Connect Flags Byte"
                            },
                            {
                                "name": "Keep Alive",
                                "length": 2,
                                "offset": None,
                                "offset_unit": "byte",
                                "encoding": "UINT",
                                "description": "Keep Alive Timer"
                            }
                        ]
                    },
                    {
                        "type": "Properties",
                        "seg_idx": 2,
                        "fields": [
                            {
                                "name": "Property Length",
                                "length": None,
                                "offset": None,
                                "offset_unit": "byte",
                                "encoding": "VBI",
                                "description": "Variable Byte Integer"
                            },
                            {
                                "name": "Session Expiry Interval",
                                "length": 4,
                                "offset": None,
                                "offset_unit": "byte",
                                "encoding": "UINT",
                                "description": "Four Byte Integer"
                            }
                        ]
                    },
                    {
                        "type": "Payload",
                        "seg_idx": 3,
                        "fields": [
                            {
                                "name": "Client Identifier",
                                "length": None,
                                "offset": None,
                                "offset_unit": "byte",
                                "encoding": "UTF8",
                                "description": "UTF-8 Encoded Client ID"
                            },
                            {
                                "name": "User Name",
                                "length": None,
                                "offset": None,
                                "offset_unit": "byte",
                                "encoding": "UTF8",
                                "description": "UTF-8 Encoded User Name"
                            },
                            {
                                "name": "Password",
                                "length": None,
                                "offset": None,
                                "offset_unit": "byte",
                                "encoding": "BIN",
                                "description": "Binary Password Data"
                            }
                        ]
                    }
                ],
                "pages": [15, 16, 17],
                "field_count": 10
            },
            {
                "label": "PUBLISH",
                "title": "Publish Packet",
                "transport_unit": "byte",
                "segments": [
                    {
                        "type": "Fixed Header",
                        "seg_idx": 0,
                        "fields": [
                            {
                                "name": "Packet Type",
                                "length": 1,
                                "offset": 0,
                                "offset_unit": "byte",
                                "encoding": "UINT",
                                "description": "MQTT Control Packet Type"
                            },
                            {
                                "name": "Remaining Length",
                                "length": None,
                                "offset": 1,
                                "offset_unit": "byte",
                                "encoding": "VBI", 
                                "description": "Variable Byte Integer"
                            }
                        ]
                    },
                    {
                        "type": "Variable Header",
                        "seg_idx": 1,
                        "fields": [
                            {
                                "name": "Topic Name",
                                "length": None,
                                "offset": None,
                                "offset_unit": "byte",
                                "encoding": "UTF8",
                                "description": "UTF-8 Encoded Topic Name"
                            },
                            {
                                "name": "Packet Identifier",
                                "length": 2,
                                "offset": None,
                                "offset_unit": "byte",
                                "encoding": "UINT",
                                "description": "Two Byte Integer"
                            }
                        ]
                    },
                    {
                        "type": "Payload",
                        "seg_idx": 2,
                        "fields": [
                            {
                                "name": "Application Message",
                                "length": None,
                                "offset": None,
                                "offset_unit": "byte",
                                "encoding": "BIN",
                                "description": "Binary Application Data"
                            }
                        ]
                    }
                ],
                "pages": [25, 26],
                "field_count": 5
            }
        ],
        "metadata": {
            "sections_count": 2,
            "messages_count": 2,
            "total_fields": 15,
            "processor": "mqtt_pdf_adapter",
            "created_at": datetime.now().isoformat()
        }
    }

def create_demo_files():
    """ÂàõÂª∫ÊºîÁ§∫Êñá‰ª∂"""
    print("üöÄ ÂàõÂª∫MQTT PDFÂ§ÑÁêÜÊµÅÊ∞¥Á∫øÊºîÁ§∫")
    print("=" * 50)
    
    # ÂàõÂª∫ËæìÂá∫ÁõÆÂΩï
    output_dir = Path("mqtt_demo_output")
    output_dir.mkdir(exist_ok=True)
    
    # ÂàõÂª∫Ê®°ÊãüSIMÊï∞ÊçÆ
    sim = create_mock_sim()
    
    # 1. ÂØºÂá∫ÂÆåÊï¥YAML
    main_yaml = output_dir / "mqtt_v5_complete.yaml"
    with open(main_yaml, 'w', encoding='utf-8') as f:
        yaml.safe_dump(sim, f, sort_keys=False, allow_unicode=True, default_flow_style=False, indent=2)
    
    print(f"‚úÖ ÂàõÂª∫‰∏ªYAMLÊñá‰ª∂: {main_yaml} ({main_yaml.stat().st_size} bytes)")
    
    # 2. ÂØºÂá∫JSONÊ†ºÂºè
    main_json = output_dir / "mqtt_v5_complete.json"
    with open(main_json, 'w', encoding='utf-8') as f:
        json.dump(sim, f, indent=2, ensure_ascii=False)
    
    print(f"‚úÖ ÂàõÂª∫JSONÊñá‰ª∂: {main_json} ({main_json.stat().st_size} bytes)")
    
    # 3. ÂàõÂª∫ÂçïÁã¨ÁöÑÊ∂àÊÅØÊñá‰ª∂
    messages_dir = output_dir / "messages"
    messages_dir.mkdir(exist_ok=True)
    
    for message in sim['spec_messages']:
        label = message['label'].lower()
        message_file = messages_dir / f"{label}_message.yaml"
        
        message_yaml = {
            'standard': sim['standard'],
            'edition': sim['edition'],
            'message': message,
            'relevant_enums': [e for e in sim['enums'] if 'packet' in e['key'] or 'qos' in e['key']]
        }
        
        with open(message_file, 'w', encoding='utf-8') as f:
            yaml.safe_dump(message_yaml, f, sort_keys=False, allow_unicode=True, default_flow_style=False, indent=2)
        
        print(f"‚úÖ ÂàõÂª∫{message['label']}Ê∂àÊÅØÊñá‰ª∂: {message_file} ({message_file.stat().st_size} bytes)")
    
    # 4. ÂàõÂª∫Êûö‰∏æÊñá‰ª∂
    enums_file = output_dir / "mqtt_enums.yaml"
    enums_data = {
        'standard': sim['standard'],
        'edition': sim['edition'],
        'enums': sim['enums']
    }
    
    with open(enums_file, 'w', encoding='utf-8') as f:
        yaml.safe_dump(enums_data, f, sort_keys=False, allow_unicode=True, default_flow_style=False, indent=2)
    
    print(f"‚úÖ ÂàõÂª∫Êûö‰∏æÊñá‰ª∂: {enums_file} ({enums_file.stat().st_size} bytes)")
    
    # 5. ÂàõÂª∫ÂØºÂÖ•Ê∏ÖÂçï
    manifest_file = output_dir / "import_manifest.yaml"
    manifest = {
        'metadata': {
            'standard': sim['standard'],
            'edition': sim['edition'],
            'created_at': datetime.now().isoformat(),
            'processor': 'mqtt_pdf_adapter_demo'
        },
        'statistics': {
            'total_messages': len(sim['spec_messages']),
            'total_enums': len(sim['enums']),
            'total_fields': sim['metadata']['total_fields']
        },
        'files': [
            {
                'path': str(f.relative_to(output_dir)),
                'type': 'yaml',
                'description': f"MQTT {f.stem.replace('_message', '').upper()} message definition"
            }
            for f in messages_dir.glob("*.yaml")
        ]
    }
    
    with open(manifest_file, 'w', encoding='utf-8') as f:
        yaml.safe_dump(manifest, f, sort_keys=False, allow_unicode=True, default_flow_style=False, indent=2)
    
    print(f"‚úÖ ÂàõÂª∫ÂØºÂÖ•Ê∏ÖÂçï: {manifest_file} ({manifest_file.stat().st_size} bytes)")
    
    # 6. ÂàõÂª∫Â§ÑÁêÜÊä•Âëä
    report_file = output_dir / "processing_report.json"
    report = {
        'processing_summary': {
            'pdf_filename': 'mqtt-v5.0-import.pdf (Ê®°Êãü)',
            'pages_processed': 30,
            'sections_found': 2,
            'tables_extracted': 4,
            'messages_created': 2,
            'total_fields': 15,
            'processing_time': '45.2 seconds',
            'confidence': 0.89
        },
        'messages': [
            {
                'label': msg['label'],
                'segments': len(msg['segments']),
                'fields': msg['field_count'],
                'pages': msg['pages']
            }
            for msg in sim['spec_messages']
        ],
        'validation': {
            'errors': [],
            'warnings': [
                "Some variable length fields lack specific byte constraints",
                "Properties section may need additional validation rules"
            ],
            'coverage': 0.92
        },
        'files_generated': [
            str(f.relative_to(output_dir)) for f in output_dir.rglob("*.yaml")
        ] + [str(f.relative_to(output_dir)) for f in output_dir.rglob("*.json")]
    }
    
    with open(report_file, 'w', encoding='utf-8') as f:
        json.dump(report, f, indent=2, ensure_ascii=False)
    
    print(f"‚úÖ ÂàõÂª∫Â§ÑÁêÜÊä•Âëä: {report_file} ({report_file.stat().st_size} bytes)")
    
    # ÊòæÁ§∫ÁªüËÆ°‰ø°ÊÅØ
    print("\nüìä Â§ÑÁêÜÁªüËÆ°:")
    print(f"   - Ê†áÂáÜ: {sim['standard']} v{sim['edition']}")
    print(f"   - Ê∂àÊÅØÊï∞Èáè: {len(sim['spec_messages'])}")
    print(f"   - ÊÄªÂ≠óÊÆµÊï∞: {sim['metadata']['total_fields']}")
    print(f"   - Êûö‰∏æÊï∞Èáè: {len(sim['enums'])}")
    
    print("\nüìÅ ÁîüÊàêÁöÑÊñá‰ª∂:")
    for file in output_dir.rglob("*"):
        if file.is_file():
            print(f"   - {file.relative_to(output_dir)} ({file.stat().st_size} bytes)")
    
    print("\nüìã Ê∂àÊÅØËØ¶ÊÉÖ:")
    for message in sim['spec_messages']:
        print(f"   üì¶ {message['label']} ({message['field_count']} Â≠óÊÆµ):")
        for segment in message['segments']:
            print(f"     - {segment['type']}: {len(segment['fields'])} Â≠óÊÆµ")
    
    print("\nüîß API‰ΩøÁî®Á§∫‰æã:")
    print("1. PDFËΩ¨YAML:")
    print('   curl -X POST "http://localhost:8000/api/mqtt/pdf_to_yaml?pages=10-50" \\')
    print('        -F "file=@mqtt-v5.0.pdf"')
    
    print("\n2. ÂÆåÊï¥ÊµÅÊ∞¥Á∫ø:")
    print('   curl -X POST "http://localhost:8000/api/mqtt/complete_pipeline?import_to_db=true&dry_run=true" \\')
    print('        -F "file=@mqtt-v5.0.pdf"')
    
    print("\n3. YAMLÂØºÂÖ•Êï∞ÊçÆÂ∫ì:")
    print(f'   curl -X POST "http://localhost:8000/api/import/yaml?yaml_path={main_yaml}&dry_run=true"')
    
    print("\n‚ú® ÊºîÁ§∫ÂÆåÊàêÔºÅÁîüÊàêÁöÑÊñá‰ª∂ÂèØ‰ª•Áõ¥Êé•Áî®‰∫éÊµãËØïÂØºÂÖ•ÂäüËÉΩ„ÄÇ")
    
    return output_dir

def main():
    """‰∏ªÂáΩÊï∞"""
    try:
        output_dir = create_demo_files()
        print(f"\nüéØ ÊºîÁ§∫Êñá‰ª∂Â∑≤ÁîüÊàêÂà∞: {output_dir}")
        print("ÊÇ®ÂèØ‰ª•‰ΩøÁî®Ëøô‰∫õÊñá‰ª∂ÊµãËØïMQTT PDFÂ§ÑÁêÜÊµÅÊ∞¥Á∫øÁöÑÂêÑ‰∏™ÂäüËÉΩ„ÄÇ")
    except Exception as e:
        print(f"‚ùå ÊºîÁ§∫ÂàõÂª∫Â§±Ë¥•: {e}")

if __name__ == "__main__":
    main()
